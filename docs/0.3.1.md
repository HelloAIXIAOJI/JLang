# JiLang 0.3.1 版本更新日志

## 目录
- [概述](#概述)
- [新特性](#新特性)
  - [双斜杠注释风格](#1-支持传统双斜杠注释风格)
  - [全面检查模式](#2-全面检查模式-check-all)
  - [变量引用语法糖](#3-支持$和￥前缀变量引用语法糖)
  - [字符串处理优化](#4-优化字符串处理)
  - [环境变量支持](#5-支持环境变量引用)
  - [try-catch错误处理](#6-增强try-catch错误处理机制)
- [代码改进](#代码改进)
  - [代码结构重构](#1-代码结构重大重构)
  - [变量引用系统](#2-变量引用系统重构)
  - [项目优化](#3-文档和项目优化)
  - [错误处理优化](#4-错误处理系统优化)
- [错误修复](#错误修复)
- [注释系统详解](#注释系统详解)
  - [注释风格对比](#注释风格对比)
  - [推荐使用场景](#推荐使用场景)
- [使用示例](#使用示例)

## 概述

JiLang 0.3.1 版本带来了多项重要更新：支持传统双斜杠注释语法、全面错误检查模式、变量引用前缀新语法、增强的错误处理机制、代码架构重构以及多项性能优化。本次更新提升了开发体验，同时保持了完全的向后兼容性。

## 新特性

### 1. 支持传统双斜杠注释风格

JiLang现在支持传统的`//`注释风格！虽然这不是标准的JSON语法，但我们添加了预处理环节，在JSON解析前自动移除所有注释，让你可以更自然地编写代码。

示例：

```json
// 这是一个文件级注释
{
    // 这是内部注释
    "program": {
        "main": {
            "body": [
                {"echo": ["Hello"]}, // 这是行尾注释
                // 这个语句被注释掉了
                {"echo": ["World"]}
            ]
        }
    }
}
```

使用双斜杠注释的优势：
- 更符合大多数开发者的习惯
- 可用于临时禁用代码片段
- 语法更简洁，不需要创建JSON注释对象
- 在任何位置都可以添加注释

注意事项：
- `//`注释在JSON解析前被完全移除，不会显示在调试输出中
- `{"comment": "..."}`风格的注释仍然保留，在调试模式下会显示
- 字符串内部的`//`不会被视为注释

### 2. 全面检查模式 (--check-all)

新增`--check-all`命令行选项，提供更全面的错误检查能力：
- 检查并统一报告脚本中的所有错误，而不是只报告第一个遇到的错误
- 检查包含：不存在的模块、未知的语句类型、语法错误、参数错误等
- 错误信息包含位置标识，便于定位问题
- 不执行脚本代码，仅进行检查
- 对于大型脚本的调试非常有用

使用方法：
```bash
jlang your_script.jl --check-all
```

输出示例：
```
全面检查模式已启用 - 检查所有类型错误并统一报告，不执行代码
检查完成，发现以下问题：
1. 未找到模块 'nonexistent_module'。您能凭空变出这个模块吗？
2. 第2个语句错误: 运行时错误: 未知的语句类型: nonexistent_function
3. 第3个语句错误: 模块错误: 未找到模块 'nonexistent_module'
```

### 3. 支持$和￥前缀变量引用语法糖

JiLang现在支持使用$和￥作为变量引用的简化语法：

- `$变量名` - 等同于 `@var.变量名`
- `￥变量名` - 等同于 `@var.变量名`（中文环境友好）

这种简化语法使得变量引用更加简洁，减少了输入量，提高了代码的可读性。

示例：

```json
{
    "program": {
        "main": {
            "body": [
                {"var": {"姓名": "张三"}},
                {"var": {"年龄": 25}},
                
                {"comment": "传统引用方式"},
                {"echo": ["姓名: ", "@var.姓名", ", 年龄: ", "@var.年龄", "\n"]},
                
                {"comment": "使用$前缀引用(适合英文键盘)"},
                {"echo": ["姓名: ", "$姓名", ", 年龄: ", "$年龄", "\n"]},
                
                {"comment": "使用￥前缀引用(适合中文环境)"},
                {"echo": ["姓名: ", "￥姓名", ", 年龄: ", "￥年龄", "\n"]}
            ]
        }
    }
}
```

变量前缀语法糖的优势：
- 代码更简洁，减少了冗余输入
- 提供了适合不同输入习惯的多种引用方式
- ￥符号为中文用户提供了更自然的体验（真的有人用中文输入法写代码或JSON吗？）
- 与其他脚本语言的变量引用风格更加一致
- 完全兼容传统的`@var.`前缀方式

### 4. 优化字符串处理

- 改进了UTF-8字符处理
- 修复了可能导致崩溃的边缘情况

### 5. 支持环境变量引用

JiLang现在增加了对系统环境变量的直接访问支持：

- 新增`@env.`前缀用于引用环境变量
- 直接从操作系统获取环境变量值
- 如果环境变量不存在，则返回`null`

示例：

```json
{
    "program": {
        "main": {
            "body": [
                {"echo": ["当前用户: ", "@env.USER", "\n"]},
                {"echo": ["系统路径: ", "@env.PATH", "\n"]},
                {"echo": ["主目录: ", "@env.HOME", "\n"]},
                {"var": {"path": "@env.PATH"}},
                {"comment": ["PATH环境变量内容:", "@var.path"]}
            ]
        }
    }
}
```

环境变量引用的优势：
- 无需手动导入环境配置
- 脚本可以访问系统信息和配置
- 便于开发跨平台和配置感知的脚本
- 与现有的变量引用系统无缝集成

### 6. 增强try-catch错误处理机制

JiLang现在提供了全面增强的错误处理机制：

- 改进的`try-catch`语句，提供更精确的错误捕获和处理
- 支持在`catch`块中访问详细的错误信息
- 新增`finally`块，无论是否发生错误都会执行
- 支持嵌套的`try-catch`结构
- 各种操作（如除零、未定义变量引用等）现在会抛出恰当的错误消息

示例：

```json
{
    "program": {
        "main": {
            "body": [
                {"comment": "基本try-catch示例"},
                {"try": {
                    "try": [
                        {"echo": ["尝试执行可能出错的代码...\n"]},
                        {"var": {"result": {"op": "div", "left": 10, "right": 0}}},
                        {"echo": ["这行不会执行，因为上面会产生除零错误\n"]}
                    ],
                    "catch": [
                        {"echo": ["捕获到错误！程序继续执行\n"]}
                    ]
                }},
                
                {"comment": "带错误信息的try-catch"},
                {"try": {
                    "try": [
                        {"echo": ["@var.undefined_variable"]}
                    ],
                    "catch": [
                        {"echo": ["捕获到错误: ", "@var.error_message", "\n"]}
                    ],
                    "error_var": "error_message"
                }},
                
                {"comment": "带finally块的try-catch"},
                {"var": {"resource": "已分配资源"}},
                {"try": {
                    "try": [
                        {"var": {"result": {"op": "div", "left": 10, "right": 0}}}
                    ],
                    "catch": [
                        {"echo": ["处理错误\n"]}
                    ],
                    "finally": [
                        {"echo": ["清理资源: ", "@var.resource", "\n"]},
                        {"var": {"resource": null}}
                    ]
                }}
            ]
        }
    }
}
```

try-catch错误处理的优势：
- 脚本可以优雅地处理各种运行时错误，无需中断整个程序执行
- 可以捕获精确的错误信息，便于调试和日志记录
- finally块确保资源能正确释放，避免资源泄漏
- 遵循现代编程语言的错误处理模式，使代码更健壮
- 完全兼容现有代码，无需修改旧脚本

## 代码改进

### 1. 代码结构重大重构

- 将原本巨大的`statement.rs`文件拆分成多个更小的模块文件，极大提升了代码的可维护性和可读性
- 创建了新的`statements`文件夹，包含以下专用模块：
  - `basic.rs` - 基本语句（var, echo, concat, comment等）
  - `control_flow.rs` - 控制流语句（if, while, for, switch）
  - `function.rs` - 函数相关语句（call, execute_function）
  - `array.rs` - 数组操作语句
  - `object.rs` - 对象操作语句
  - `regex.rs` - 正则表达式操作
  - `exec.rs` - 系统命令执行
  - `mod.rs` - 模块定义和主要语句执行函数

- 每个模块文件专注于特定的功能组，使代码更加清晰和易于维护
- 保持了完全的向后兼容性，现有脚本无需任何修改即可运行

### 2. 变量引用系统重构

- 创建了专门的`variable_reference.rs`文件，集中处理所有变量引用逻辑
- 实现了`VariableReference`结构体和`ReferenceType`枚举，提供统一的变量引用处理机制
- 支持的引用类型包括：
  - `@var.` - 变量引用
  - `@const.` - 常量引用
  - `@params.` - 函数参数引用
  - `@env.` - 环境变量引用（新增）
- 重构后的代码具有以下优势：
  - 更好的模块化 - 所有引用处理逻辑集中在一处
  - 更易维护 - 添加新的引用类型只需修改`variable_reference.rs`文件
  - 更一致的代码风格 - 所有文件使用统一的API处理变量引用
  - 更好的类型安全 - 使用枚举替代字符串硬编码
- 统一了所有文件（`array.rs`、`object.rs`、`control_flow.rs`等）中的变量引用处理
- 提供了`resolve_value`方法，用于处理包括环境变量在内的所有类型引用

### 3. 文档和项目优化
- 更新了帮助信息，包含了新的注释功能
- 更新了文档，添加了关于双斜杠注释的说明
- 添加了新的示例文件`double_slash_comment_test.jl`
- 移除了未使用的toml依赖，减小了项目体积并加快了构建速度（实际上是之前用于读取版本的，但逻辑实在是太傻逼了就改了。理论上打包体积变小）

### 4. 错误处理系统优化

- 重构了错误处理机制，提供更详细的错误类型和消息
- 在`error.rs`文件中集中管理所有错误消息，便于国际化和定制
- 新增特定领域的错误类型和消息：
  - `math`模块错误：如除零错误、无效数值转换
  - 变量引用错误：未定义变量、类型不匹配等
  - 函数调用错误：参数不足、类型错误等
- 改进了错误消息的可读性和一致性，使用友好的表达方式
- 优化了try-catch语句的实现，提高了性能和可靠性
- 确保所有模块能够正确抛出和处理错误，而不是静默失败

## 错误修复

- 修复了预处理阶段可能导致的崩溃问题
- 优化了错误消息格式
- 修复了￥前缀变量引用的UTF-8多字节字符处理问题，现在可以正确解析￥符号
- 修复了数学运算中的除零错误处理问题，现在会抛出适当的错误而不是返回NaN
- 修复了变量引用解析的几个边缘情况问题
- 改进了嵌套try-catch结构的错误传播机制
- 修复了变量引用系统中的嵌套属性访问问题，现在可以正确解析和访问嵌套的对象属性（如`@var.user.profile.name`）
- 扩展了变量引用系统，添加对嵌套属性、数组索引和环境变量的全面支持，使所有引用类型都能一致地处理嵌套结构

## 注释系统详解

JiLang现在支持两种注释风格，各有优缺点，可根据不同场景选择使用。

### 注释风格对比

#### 双斜杠注释 (`//`)

```json
// 这是一个整行注释
{"var": {"count": 42}} // 这是行尾注释
```

**优点**：
- 语法简洁，编写快速
- 熟悉的语法，与大多数编程语言一致
- 可以注释掉整行代码（临时禁用）
- 可以添加行尾注释
- 可在JSON任何位置使用（包括对象外部）

**缺点**：
- 不是标准JSON语法
- 在调试模式下不可见，被预处理完全移除
- 不能包含变量引用等动态内容

#### 注释对象 (`{"comment": "..."}`)

```json
{"comment": "这是一个注释"},
{"comment": ["这是", "多部分", "注释，变量值:", "@var.count"]}
```

**优点**：
- 是标准JSON语法的一部分
- 在调试模式下可见，便于调试
- 可以包含变量引用，显示实时值
- 支持多部分组合注释

**缺点**：
- 语法较冗长
- 只能作为JSON对象的一部分使用
- 不能用于行尾注释

### 推荐使用场景

我们建议根据不同场景选择合适的注释风格：

1. **开发阶段**：
   - 使用`//`注释进行快速注释、临时禁用代码和添加简单说明
   - 适合频繁修改和测试的代码

2. **调试阶段**：
   - 使用`{"comment": "..."}`对象注释显示中间变量值
   - 特别是使用`{"comment": ["说明:", "@var.变量"]}`格式查看变量实时值

3. **文档和维护**：
   - 在重要算法或逻辑处使用`{"comment": "..."}`注释
   - 对于简单的代码说明，使用`//`注释

4. **混合使用**：
   ```json
   // 这部分实现了快速排序算法
   {"comment": "开始排序，数组大小: "},
   {"array.length": ["@var.items"]},
   {"comment": ["数组元素数量: ", "@var.result"]}
   ```

两种注释风格可以互补使用，根据具体需求选择最合适的方式。

## 使用示例

### 完整示例

```json
// 这是一个使用//注释的文件示例
{
    "include": ["math"], // 包含数学模块
    "program": {
        "main": {
            "body": [
                // 使用双斜杠注释
                {"echo": ["测试 // 注释:\n\n"]},
                
                {"var": {"number": 25}}, // 设置一个变量
                
                // 使用数学模块计算平方根
                {"math.sqrt": ["@var.number"]},
                {"var": {"sqrt_result": "@var.result"}},
                
                // 访问环境变量示例
                {"echo": ["当前用户: ", "@env.USER", "\n"]},
                
                // 以下使用传统的JSON对象注释方式
                {"comment": "使用comment对象的注释"},
                {"echo": ["平方根结果: ", "@var.sqrt_result", "\n"]}
            ]
        }
    }
}
```
